create table "public"."accounts" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "account_type" text not null,
    "truelayer_account_id" text not null,
    "truelayer_display_name" text not null,
    "connection_id" bigint not null
);


alter table "public"."accounts" enable row level security;

create table "public"."connections" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "access_token" text not null,
    "expires_at" timestamp with time zone,
    "refresh_token" text,
    "key_id" uuid not null default '1ada15e6-5c3c-43bc-9586-aa1622b76ef5'::uuid
);


alter table "public"."connections" enable row level security;

create table "public"."job_definitions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null,
    "card_account_id" bigint not null,
    "cash_account_id" bigint not null,
    "reserve_account_id" bigint not null,
    "last_synced_at" timestamp with time zone
);


alter table "public"."job_definitions" enable row level security;

CREATE UNIQUE INDEX accounts_pkey ON public.accounts USING btree (id);

CREATE UNIQUE INDEX connections_pkey ON public.connections USING btree (id);

CREATE UNIQUE INDEX job_definitions_pkey ON public.job_definitions USING btree (id);

alter table "public"."accounts" add constraint "accounts_pkey" PRIMARY KEY using index "accounts_pkey";

alter table "public"."connections" add constraint "connections_pkey" PRIMARY KEY using index "connections_pkey";

alter table "public"."job_definitions" add constraint "job_definitions_pkey" PRIMARY KEY using index "job_definitions_pkey";

alter table "public"."accounts" add constraint "accounts_connection_id_fkey" FOREIGN KEY (connection_id) REFERENCES connections(id) not valid;

alter table "public"."accounts" validate constraint "accounts_connection_id_fkey";

alter table "public"."connections" add constraint "connections_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."connections" validate constraint "connections_user_id_fkey";

alter table "public"."job_definitions" add constraint "job_definitions_card_account_id_fkey" FOREIGN KEY (card_account_id) REFERENCES accounts(id) not valid;

alter table "public"."job_definitions" validate constraint "job_definitions_card_account_id_fkey";

alter table "public"."job_definitions" add constraint "job_definitions_cash_account_id_fkey" FOREIGN KEY (cash_account_id) REFERENCES accounts(id) not valid;

alter table "public"."job_definitions" validate constraint "job_definitions_cash_account_id_fkey";

alter table "public"."job_definitions" add constraint "job_definitions_reserve_account_id_fkey" FOREIGN KEY (reserve_account_id) REFERENCES accounts(id) not valid;

alter table "public"."job_definitions" validate constraint "job_definitions_reserve_account_id_fkey";

alter table "public"."job_definitions" add constraint "job_definitions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."job_definitions" validate constraint "job_definitions_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.connections_encrypt_secret_access_token()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
		BEGIN
		        new.access_token = CASE WHEN new.access_token IS NULL THEN NULL ELSE
			CASE WHEN new.key_id IS NULL THEN NULL ELSE pg_catalog.encode(
			  pgsodium.crypto_aead_det_encrypt(
				pg_catalog.convert_to(new.access_token, 'utf8'),
				pg_catalog.convert_to((new.id::text)::text, 'utf8'),
				new.key_id::uuid,
				NULL
			  ),
				'base64') END END;
		RETURN new;
		END;
		$function$
;

CREATE OR REPLACE FUNCTION public.connections_encrypt_secret_refresh_token()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
		BEGIN
		        new.refresh_token = CASE WHEN new.refresh_token IS NULL THEN NULL ELSE
			CASE WHEN new.key_id IS NULL THEN NULL ELSE pg_catalog.encode(
			  pgsodium.crypto_aead_det_encrypt(
				pg_catalog.convert_to(new.refresh_token, 'utf8'),
				pg_catalog.convert_to((new.id::text)::text, 'utf8'),
				new.key_id::uuid,
				NULL
			  ),
				'base64') END END;
		RETURN new;
		END;
		$function$
;

create or replace view "public"."decrypted_connections" as  SELECT connections.id,
    connections.created_at,
    connections.user_id,
    connections.access_token,
        CASE
            WHEN (connections.access_token IS NULL) THEN NULL::text
            ELSE
            CASE
                WHEN (connections.key_id IS NULL) THEN NULL::text
                ELSE convert_from(pgsodium.crypto_aead_det_decrypt(decode(connections.access_token, 'base64'::text), convert_to((connections.id)::text, 'utf8'::name), connections.key_id, NULL::bytea), 'utf8'::name)
            END
        END AS decrypted_access_token,
    connections.expires_at,
    connections.refresh_token,
        CASE
            WHEN (connections.refresh_token IS NULL) THEN NULL::text
            ELSE
            CASE
                WHEN (connections.key_id IS NULL) THEN NULL::text
                ELSE convert_from(pgsodium.crypto_aead_det_decrypt(decode(connections.refresh_token, 'base64'::text), convert_to((connections.id)::text, 'utf8'::name), connections.key_id, NULL::bytea), 'utf8'::name)
            END
        END AS decrypted_refresh_token,
    connections.key_id
   FROM connections;


CREATE TRIGGER connections_encrypt_secret_trigger_access_token BEFORE INSERT OR UPDATE OF access_token ON public.connections FOR EACH ROW EXECUTE FUNCTION connections_encrypt_secret_access_token();

CREATE TRIGGER connections_encrypt_secret_trigger_refresh_token BEFORE INSERT OR UPDATE OF refresh_token ON public.connections FOR EACH ROW EXECUTE FUNCTION connections_encrypt_secret_refresh_token();


